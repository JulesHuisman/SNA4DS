---
title: "Lab 01b - Network Analysis in R"
output: 
  learnr::tutorial:
    fig_caption: no
    progressive: true
    allow_skip: no
    toc: true
    toc_depth: 3
    theme: readable
runtime: shiny_prerendered
---


```{r setup, include=FALSE}
library(learnr)
library(gradethis)
# library(magrittr)
tutorial_options(exercise.checker = gradethis::grade_learnr)
knitr::opts_chunk$set(echo = TRUE, include = TRUE)
```


## Introduction
There are two main packages in R to construct network objects. 

__The first is `igraph`.__ The `igraph` package actually has implementations in
C/C++, Python, Mathematica, and R. Although the `igraph` functions are slightly
different between these three environments, you will benefit from the code in
this course if you want to use `igraph` in another environment at a later time.

The general `igraph` page is [here](https://igraph.org/) and the 
extended documentation for the R version is [here](https://igraph.org/r/#docs).

__The second is the (creatively named) `network` package.__ This package
implements a class of _network_ objects that can be analyzed by packages such as
`sna` (these packages are all part of the _statnet_ suite of packages, that all
work together). We will make use of this package a lot as well.

Unfortunately, the `igraph` and `network` network objects are not
interchangeable, the objects that you create in `igraph` can not be used in
`network`/`sna`, and vice versa. This is unfortunate, because these packages
differ in their functionality, so you often might want to combine some `igraph`
functions with some `sna` functions in a single analysis. Fortunately, but there
are ways to move between the packages by transforming the object to fit the
other package. It is a bit cumbersome, but you will have to be able to do it
nonetheless.

## igraph
Let's start with the `igraph` package.

We can easily create an undirected network and add a few nodes and links. Nodes
are called _vertices_ and referred to by integer IDs; links are called _edges_.

```{r book_1_2a, echo = TRUE, include = TRUE}
g <- igraph::make_empty_graph()

# add one vertex
g <- igraph::add_vertices(g, 1)
plot(g)

# add two more vertices
g <- igraph::add_vertices(g, 2)
plot(g)

# add an edge from 1 -> 2
g <- igraph::add_edges(g, c(1, 2))
g
plot(g)
```



### Book, section 1.2
The code below generates an undirected graph with three edges. The numbers are
interpreted as vertex IDs, so the edges are 1–>2, 2–>3, 3–>1.

```{r, include = TRUE, echo = TRUE}
g1 <- igraph::graph( edges=c(1,2, 2,3, 3, 1), n=3, directed=F ) 
plot(g1)
class(g1)
g1
```

As you see, `igraph` creates a network object of class _igraph_. 

```{r, echo = TRUE}
g2 <- igraph::graph( c("Jane", "Ali", "Ali", "Hassan", "Jane", "Hassan")) # named vertices

# When the edge list has vertex names, the number of nodes is not needed
plot(g2)
g2
```


You access the set of nodes (_vertices_), links (_edges_), and neighbors as follows:

```{r}
igraph::V(g2)
igraph::E(g2)
igraph::neighbors(g2, "Jane")

# you can also access Jane through her ID, she is the first vertex.
# NOTE: R starts counting at 1 (while Python starts counting at 0)
igraph::neighbors(g2, 1)
```

Wanna loop over the nodes?
```{r}
for (n in igraph::V(g2)) {
  cat("The neighors of vertex", n, ":", igraph::neighbors(g2, n), "\n")
}

# or, with vertex names
for (n in igraph::V(g2)$name) {
  cat("The neighors of vertex", n, ":", igraph::neighbors(g2, n)$name, "\n")
}
```

Looping over the links:
```{r}
for (edge in igraph::E(g2)) {
  print(igraph::E(g2)[edge])
}
```

To get the number of vertices and edges, you do the following

```{r}
igraph::ecount(g2)
igraph::vcount(g2)
```

To get the partners of a given node, or just the vertices linking to or from,
you can do the following (for actor "Ali)":

```{r}
igraph::neighbors(g2, 2, mode = "all") # incoming and outgoing
igraph::neighbors(g2, 2, mode = "in") # incoming 
igraph::neighbors(g2, 2, mode = "out") # outgoing
```

The `igraph` package has many functions available that will generate networks with 
particular structures, in case you really want to start from a specific network 
design. Here are just a few:


```{r}
plot(igraph::make_full_bipartite_graph(4, 5))
plot(igraph::make_ring(4))
plot(igraph::make_star(6))
plot(igraph::make_star(6, mode = "undirected", center = 2))
```

We will meet more interesting network structures later in this course. Anyway, 
you now have all the R code to do the equivalent to section 1.2 in the book. 

Let's move on from here.

### Creating small graphs
Small graphs can also be generated using symbols in the
`igraph::graph_from_literal` function:

* "--" for undirected tie
* "+-" or "-+" for directed ties pointing to the left or to the right
* "++" for a symmetric tie
* ":" for sets of vertices.


```{r, echo = TRUE}
g3 <- igraph::graph_from_literal(Mary++Magdalena++Janet, Jim+-Pete, Mary-+Roberto, 
Mary-+Ivan-+Kelly:Danielle, Jesse, Janis, Fabio, Rumana)
plot(g3, edge.arrow.size = .5, vertex.color = "gold", vertex.size = 15, 
     vertex.frame.color = "gray", vertex.label.color = "black", 
     vertex.label.cex = 0.8, vertex.label.dist = 2, edge.curved = 0.2) 
g3
```
            
This works just fine when you have small networks (or you want to generate some 
simple artificial networks to test your data), but is not feasible for larger 
networks. 

### Basic network data types
Let's continue with network `g3`. 

#### Adjacency matrix

An _adjacency matrix_ is a matrix in which the rows and columns represent
different nodes. In an unweighted adjacency matrix, the edges (i.e., lines) are
0 or 1, indicating whether these two nodes are connected. If two nodes are
connected, they are said to be _adjacent_ (hence the name, _adjacency matrix_).
In a weighted matrix, however, the cells can have different values, indicating
different edge qualities (or tie strengths).

For this network, the adjacency matrix looks as follows

```{r}
igraph::as_adjacency_matrix(g3, sparse = FALSE)
```

Note the argument `sparse = FALSE` in the code above. This displays the zeroes
in the adjacency matrix. When  `sparse = TRUE`, in the output 0's are replaced
with a period, making it easier to see very large matrices.

```{r}
igraph::as_adjacency_matrix(g3, sparse = TRUE)
```

When the network is undirected and unweighted, the corresponding adjacency
matrix is symmetrical and binary.


### Edge List
A very common datastructure is the _edge list_. An edge list is a two-column
matrix, with the sender in the first column and the reciever in the second (ie.
the edge goes from the vertex in the first column to the vertex in the second
column). In an undirected network, the order of the vertices don’t matter. For
weighted networks, you may have a third column that indicates the edge weight.


```{r}
igraph::as_edgelist(g3)
```

### Adjacency List
An _adjacency list_ (or _node list_, is a list that presents the ‘focal’ node
and then all the other nodes that are connected to it (i.e., that are "adjacent"
to it). This looks as follows:

```{r}
igraph::as_adj_list(g3, mode = "total")
```
As you can see, this isn't nice for directed graphs, but it does work.
Sometimes, this is exactly the data that you have: for each node you know whom
it is connected to. Then, this is the data type to use.

### Going from Data to Networks
how to construct networks from data frames and edge lists


## _network_
the network package, and sna for some visualization
do some of the same stuff as above, but now with the network package


## _intergraph_
Moving between the two packages





