---
title: "SNA4DS cheatsheet<br><br>"
output:
  html_document:
    theme: flatly
    toc: yes
    number_sections: yes
vignette: |
  %\VignetteIndexEntry{SNA4DS cheatsheet} 
  %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo = FALSE,
  comment = "#>",
  eval = FALSE,
  echo = TRUE
)
```


<style type="text/css">
.main-container {
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
}
</style>


<style type="text/css">
pre {
	border-style: hidden;
}
</style>


<br><br>

Below we summarize the main `R` functions that are used in the SNA4DS course. 
We will not explain the underlying concepts here, but refer you to the lectures, 
labs, and slides of the course for that.

The aim of this "cheatsheet" is that it provides you with an overview of 
the main functions you will need throughout the course. 
We hope that it can provide a useful reference for you, as you develop 
and apply your network analysis skills.

> NOTE:
>
> Most functions have multiple arguments. Our aim is not to show and discuss 
the various arguments that exist, because that would yield an unwieldy and 
very long document. Rather, we recommend you use your `R` skills and 
use the help function `?` and `help` and other approaches we teach you 
in this course to learn about the details of a specific function. 
If you still can't figure it out, contact us and we'll assist you.


<br><br><br>

# General `SNA4DS` functions

<br>

## `SNA4DS::check_SNA4DS()`

This function checks if a newer version of the `SNA4DS` package is 
available on Github. 
It also offers you to install the new version if one is available.

## `SNA4DS::SNA4DS_tutorials()`

This function lists the currently available tutorials in your installed 
version of `SNA4DS` and allows you to pick the one you want to run from a list.

## `SNA4DS::make_matrix_from_vertex_attribute`

This function turns a vertex attribute into a matrix with a value for each edge 
in a graph.

The input is a graph object of class `igraph` or `network`, 
the name (`name`) of the required attribute, 
and the name of the function (`measure`) you want to perform on the attribute.

For example, 

```{r}
SNA4DS::make_matrix_from_vertex_attribute(g, 
                                  name = "vertexAttributeName",
                                  measure = "max")
```

creates a matrix where cell (*i*, *j*) represents the maximum value for 
dyad (*i*, *j*) of their attribute called "vertexAttributeName". 

The `diag` argument determines what is put on the diagonal of the matrix. 
The default is to fill the diagonal with 0's, but you can override this.

Beware if missing values occur in the chosen vertex attribute, currently no 
check is made for missing values and you need to check the corresponding 
cells of the outcome matrix if it did what you wanted.

You can also just provide the function with a numeric vector and it will 
calculate the matrix for you based on that alone. 
Of course, in this case you have to make sure yourself that the values 
in the vector are in the same order as in the network.
Here is an example where a vector with values c(1, 2, 3, 4, 5) is turned 
into a matrix with the absolute difference values in the cells.

```{r}
SAN4DS::make_matrix_from_vertex_attribute(1:5, measure = "absdiff")
```

<br><br><br>

# Generating and manipulation graph objects {#generate}

There are two main packages for basic graph generation and manipulation: 
the `igraph` package and the `statnet` package. 
Actually, `statnet` is a suite of packages that work together. 
In this course, we will will make use 
of several packages from the `statnet` suite.

The `igraph` package creates a graph object of type `igraph`. 
The `statnet` suite creates a graph object of type `network`. 
There are many things you can do in both packages. 
Both packages can generate graphs and do basic manipulation, 
so here you should just use the package whose API you like best. 
The `igraph` package provides more mathematical functions to apply 
to the graph data and the `statnet` suite provides loads of 
statistical models that the `igraph` package does not do.

Below, we provide you with an overview of the functions that do 
basic data generation and manipulation of graph datasets. 
We show the functions in both packages that do equivalent things.

<br>

```{r, echo = FALSE, eval = TRUE}
htmltools::includeHTML("html_generate.html")
```

<br> 

## `SNA4DS` functions

The `SNA4DS` package offers a few functions that assist with the manipulation 
of graph data in `R`.

* `SNA4DS::makeEdgelist(names = NULL, attribute = NULL)`

The input is a data.frame (`names`) with edge information. 
The `attribute` is a vector that contains a node attribut for those vertices.

The function returns a vector or data.frame that can be read into 
`igraph` or `network`.

* `SNA4DS::makeNodelist(names = NULL, attribute = NULL)`

The input is a data.frame (`names`) with edge information. 
The `attribute` is another data.frame that contains the values of those edges.

The function returns an edgelist that can be read into `igraph` or `network`.



* `SNA4DS::extract_all_vertex_attributes(g)`

The `SNA4DSextract_all_vertex_attributes(g)` function extracts all vertex 
attributes from a graph object and puts them together into a data.frame. 
The function works with both `igraph` and `network` class objects.


<br><br><br>

# `intergraph`: moving between `igraph` and `network`

There are two ways to convert a graph object between the two classes. 
The first is to convert the object into another representation and import that 
into the other package.
For example, one could first convert an `igraph` object into an adjacency 
matrix and read that in in `network`. 

A straightforward way to convert between the two classes is to use the 
`intergraph` package. This is the sole purpose of this package.

You coerce a `network` object into a `igraph` object as follows:

```{r}
intergraph::asIgraph(g)
```

You coerce a `igraph` object into a `network` object as follows:

```{r}
intergraph::asNetwork(g)
```

The `intergraph` package also has a useful function that turns a `network` or 
`igraph` object into a data.frame: 

```{r}
intergraph::asDF(g)
```

If you have a network in both `igraph` and `network` versions, 
you can check if they are (nearly) the same through the following `intergraph` 
function:

```{r}
# perform the test, result is TRUE or FALSE
intergraph::netcompare(network1, network2, test = TRUE)

# return the results of all the tests
intergraph::netcompare(network1, network2, test = FALSE)
```
<br><br><br>

# Computing measures

Below you will find a table with the main measures that are covered in the 
course. 
When both `igraph` and `network` provide a function for the measure, you will 
find both of them in the table.

<br>

```{r, echo = FALSE, eval = TRUE}
htmltools::includeHTML("html_measures.html")
```

<br><br><br>

# Communities and other subgroups

--> Claudia, this is for you. The part I would like to add is the following 
(but feel free to make changes to it):

## Walktrap algorithm
You can determine community structure via short random walks using the 
*walktrap* algorithm, as implemented in `igraph::walktrap.community`. 

You run this analysis as follows:

```{r}
igraph::cluster_walktrap(g)
```

You can adjust some of the settings, but the default setting almost 
always works well.
A general analysis approach works as follows:

```{r}
# run the algorithm
walk <- igraph::cluster_walktrap(g)

# get an overview of the results
print(walk)

# get the modularity score
igraph::modularity(walk)

# who is member of which community
igraph::communities(walk)

# which community is a vertex member of
igraph::membership(walk)

# number of communities
length(walk)

# size of each community
igraph::sizes(walk)

# which edge connects multiple communities
igraph::crossing(walk, g)

# plot the network, highlighting the communities
plot(walk, g)
```

I you are so inclined, 
you can plot the community division as a dendrogram, as follows:

```{r}
stats::as.hclust(walk) %>% plot()
```



<br><br><br>

# Plotting

<br> 

## Basic plotting in `igraph`

--> Feel free to remove this section or otherwise reorganize this part.

## Basic plotting in `network`

--> Feel free to remove this section or otherwise reorganize this part.

## Basic plotting in `ggraph`

--> Feel free to remove this section or otherwise reorganize this part.

## SNA4DS functions
The `SNA4DS` package contains a function to plot centrality scores of the 
vertices. 
The function and its options are specified as follows:

```{r}
SNA4DS::centralityChart(
  net,
  measures = c("betweenness", "closeness", "degree"),
  directed = igraph::is.directed(net),
  mode = c("all", "out", "in", "total"),
  normalized = TRUE,
  path = FALSE
)
```

The function takes an object of class `igraph` and plots three centrality 
scores, so you can visually compare them. 
Make sure to pick the required value for `mode` (the default is "all"). 
You can leave `path` to `FALSE`, which will always work. 
If you want the dots to be connected (which can yield a more insightful plot), 
set `path = TRUE`, you then get a *path plot*. 
In some cases this yields a messy or messed-up plot, 
so then set `path = FALSE` again.

<br><br><br>

# Statistical models

Here is an overview of the statistical models discussed in the course.

<br>

```{r, echo = FALSE, eval = TRUE}
htmltools::includeHTML("html_models.html")
```

<br>

## Network autocorrelation models
The network autocorrelation model is run through the `sna::lnam` function.
The basic function call is as follows:

```{r}
sna::lnam(y, x = NULL, W1 = NULL, W2 = NULL)
```

Here, 

* `y` is a vector with a value for each vertex. 
The implementation in `sna::lnam` is only appropriate for continuous 
dependent variables.

* `W` is a matrix of the same dimension as the network, containing the weights 
that drive the network influence process. 
You need to specify `W1` and can include a second weight matrix `W2` if you want.

* `x` is a matrix with a row per vertex. Make sure to include a column with 1's, 
so an intercept is included. 
Make sure to include column names, so you get informative output.

There is a useful `summary` method (that shows you an overview of the results) 
and a `plot` method (that you use to check model assumptions).

<br>

## Conditional Uniform graphs (CUG)

There are two methods to perform a conditional Uniform graph test.

The first is to generate the graphs manually and calculate the 
measures on each graph.
Generation of these graphs can be done using `igraph::sample_gnm` (which 
conditions on size and density), `igraph::sample_gnp` (another way to 
condition on size and density). 
The equivalent functions in `sna` are `sna::rgraph` and `sna::rgnm`. 
See [the data generation table](#generate) for these functions.

The second approach is to use a function that does the graph generation and 
computes the network measure for you. 
The preferred is `sna::cugtest`, which is specified as follows:

```{r}
sna::cug.test(g, FUN, mode = c("digraph", "graph"), cmode = c("size", 
    "edges", "dyad.census"), reps = 1000, 
    ignore.eval = TRUE, FUN.args = list())
```

See the `sna` help function for details.

Here

* `FUN` is the function that needs to be calculated on each graph

* `FUN.args` contains any arguments that are required for the function you 
specified in `FUN`

* `cmode` determines the type of graphs that are drawn (ie. what you condition 
on). The options are 
  - "size": this generates graphs with a particular size and density 0.5. 
  You rarely want this.
  
  - "edges": this conditions on a specific edge count (or an 
  exact edge value distribution)
  
  - "dyad.census": this conditions on a dyad census (or dyad value distribution)


For example, in order to test whether the transitivity in your graph `g` is 
exceptional for a network of the same size and density as in `g`, you would run

```{r}
sna::cug.test(g, sna::gtrans, cmode = "edges")
```

It is wise to always explicitly tell the function whether your graph is 
directed or not, so a better way to specify the previous function is

```{r}
sna::cug.test(g, mode = "graph", FUN = sna::gtrans, 
              cmode = "edges", reps = 1000, 
              FUN.args = list(mode = "graph"))
```

Testing the betweenness centralization of you network `g` could be 
performed as follows, again conditioning on size and density:

```{r}
sna::cug.test(g,
              sna::centralization,
              FUN.arg=list(FUN = sna::betweenness), 
              mode="graph", 
              cmode="edges")
```

There is also a useful `plot` method for the result of the CUG test.

<br>

## QAP test

There are two methods to perform a QAP test.

The first is to manually permute the graph.
Generation of these graphs can be done using `igraph::permute` or `sna::rmperm`. 
See [the data generation table](#generate) for these functions.

The second approach is to use a function that does the graph permutation and 
computes the required measure (typically a correlation) for you. 
The preferred is `sna::qaptest`, which is specified as follows:

```{r}
sna::qaptest(g, FUN, reps = 1000, ...)
```

See the `sna` help function for details.

Here

* `FUN` is the function that needs to be calculated after each 
permutation

* `...` contains any arguments that are required for the function you 
specified in `FUN`

Typically, you want to test the correlation between two graphs, as follows:

```{r}
sna::qaptest(list(firstNetwork, secondNetwork), 
             FUN = sna::gcor, reps = 1000,
             g1 = 1, g2 = 2)
```

There is a useful `summary` method and a `plot` method for the output of the 
function.

<br>

## QAP linear regression

QAP linear regression is performed through the `sna::netlm` function.
The function looks as follows:


```{r}
sna::netlm(y, x, intercept = TRUE, mode = "digraph", 
    nullhyp = "qapspp", reps = 1000)
```

Make sure to always set `intercept = TRUE` and `nullhyp = "qapspp"`. 
For small networks, 1000 replications should be enough, 
for larger networks you should typically use a higher number (say, 2000).

As an example, this is how you specify a model where graph `g` is modeled 
as a linear function of graphs `g1`, `g2`, and `g3`.

```{r}
mod <- sna::netlm(y = g, x = list(g1, g2, g3), intercept = TRUE,
                              nullhyp = 'qapspp', reps = 1001)
mod$names <- c("Intcpt", "Net1", "Net2", "Net3")
summary(mod)
```

It is wise to add the names of the networks to the output object, like you 
see above. That is not structly necessary, but it makes the output of the 
function easier to read.

<br>

## QAP logistic regression

QAP logistic regression is performed through the `sna::netlogit` function.
The function looks as follows:


```{r}
sna::netlogit(y, x, intercept = TRUE, mode = "digraph", 
    nullhyp = "qapspp", reps = 1000)
```

Make sure to always set `intercept = TRUE` and `nullhyp = "qapspp"`. 
For small networks, 1000 replications should be enough, 
for larger networks you should typically use a higher number (say, 2000).

As an example, this is how you specify a model where binary graph `g` is modeled 
as a function of graphs `g1`, `g2`, and `g3`.

```{r netlogit1, exercise = TRUE}
mod <- sna::netlogit(g, list(g1, g2, g3), 
                     intercept = TRUE,
                     nullhyp = "qapspp", reps = 1001)
mod$names <- c("Intcpt", "Net1", "Net2", "Net3")
summary(mod)
```

<br>

## Exponential Random Graph Model (ERGM)

<br>

