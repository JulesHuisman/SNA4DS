---
title: "SNA4DS cheatsheet<br><br>"
output:
  html_document:
    theme: flatly
    toc: yes
    number_sections: yes
    anchor_sections: false

vignette: |
  %\VignetteIndexEntry{SNA4DS cheatsheet} 
  %\VignetteEngine{knitr::rmarkdown} 
  \VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo = FALSE,
  comment = "#>",
  eval = FALSE,
  echo = TRUE
)

```


<style type="text/css">
.main-container {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


<style type="text/css">
pre {
	border-style: hidden;
}
</style>


<br><br>

Below we summarize the main `R` functions that are used in the SNA4DS course. 
We will not explain the underlying concepts here, but refer you to the lectures, 
labs, and slides of the course for that.

The aim of this "cheatsheet" is that it provides you with an overview of 
the main functions you will need throughout the course. 
We hope that it can provide a useful reference for you, as you develop 
and apply your network analysis skills.

> NOTE:
>
> Most functions have multiple arguments. Our aim is not to show and discuss 
the various arguments that exist, because that would yield an unwieldy and 
very long document. Rather, we recommend you use your `R` skills and 
use the help function `?` and `help` and other approaches we teach you 
in this course to learn about the details of a specific function. 
If you still can't figure it out, contact us and we'll assist you.


<br><br><br>

# General `SNA4DS` functions

<br>

## `SNA4DS::check_SNA4DS()`

This function checks if a newer version of the `SNA4DS` package is 
available on Github. 
It also offers you to install the new version if one is available.

## `SNA4DS::SNA4DS_tutorials()`

This function lists the currently available tutorials in your installed 
version of `SNA4DS` and allows you to pick the one you want to run from a list.

## `SNA4DS::make_matrix_from_vertex_attribute`

This function turns a vertex attribute into a matrix with a value for each edge 
in a graph.

The input is a graph object of class `igraph` or `network`, 
the name (`name`) of the required attribute, 
and the name of the function (`measure`) you want to perform on the attribute.

For example, 

```{r}
SNA4DS::make_matrix_from_vertex_attribute(g, 
                                  name = "vertexAttributeName",
                                  measure = "max")
```

creates a matrix where cell (*i*, *j*) represents the maximum value for 
dyad (*i*, *j*) of their attribute called "vertexAttributeName". 

The `diag` argument determines what is put on the diagonal of the matrix. 
The default is to fill the diagonal with 0's, but you can override this.

Beware if missing values occur in the chosen vertex attribute, currently no 
check is made for missing values and you need to check the corresponding 
cells of the outcome matrix if it did what you wanted.

You can also just provide the function with a numeric vector and it will 
calculate the matrix for you based on that alone. 
Of course, in this case you have to make sure yourself that the values 
in the vector are in the same order as in the network.
Here is an example where a vector with values c(1, 2, 3, 4, 5) is turned 
into a matrix with the absolute difference values in the cells.

```{r}
SAN4DS::make_matrix_from_vertex_attribute(1:5, measure = "absdiff")
```

<br><br><br>

# Generating and manipulation graph objects {#generate}

There are two main packages for basic graph generation and manipulation: 
the `igraph` package and the `statnet` package. 
Actually, `statnet` is a suite of packages that work together. 
In this course, we will will make use 
of several packages from the `statnet` suite.

The `igraph` package creates a graph object of type `igraph`. 
The `statnet` suite creates a graph object of type `network`. 
There are many things you can do in both packages. 
Both packages can generate graphs and do basic manipulation, 
so here you should just use the package whose API you like best. 
The `igraph` package provides more mathematical functions to apply 
to the graph data and the `statnet` suite provides loads of 
statistical models that the `igraph` package does not do.

Below, we provide you with an overview of the functions that do 
basic data generation and manipulation of graph datasets. 
We show the functions in both packages that do equivalent things.

<br>

```{r, echo = FALSE, eval = TRUE}
htmltools::includeHTML("html_generate.html")
```

<br> 

## `SNA4DS` functions

The `SNA4DS` package offers a few functions that assist with the manipulation 
of graph data in `R`.

* `SNA4DS::makeEdgelist(names = NULL, attribute = NULL)`

The input is a data.frame (`names`) with edge information. 
The `attribute` is a vector that contains a node attribut for those vertices.

The function returns a vector or data.frame that can be read into 
`igraph` or `network`.

* `SNA4DS::makeNodelist(names = NULL, attribute = NULL)`

The input is a data.frame (`names`) with edge information. 
The `attribute` is another data.frame that contains the values of those edges.

The function returns an edgelist that can be read into `igraph` or `network`.



* `SNA4DS::extract_all_vertex_attributes(g)`

The `SNA4DSextract_all_vertex_attributes(g)` function extracts all vertex 
attributes from a graph object and puts them together into a data.frame. 
The function works with both `igraph` and `network` class objects.


<br><br><br>

# `intergraph`: moving between `igraph` and `network`

There are two ways to convert a graph object between the two classes. 
The first is to convert the object into another representation and import that 
into the other package.
For example, one could first convert an `igraph` object into an adjacency 
matrix and read that in in `network`. 

A straightforward way to convert between the two classes is to use the 
`intergraph` package. This is the sole purpose of this package.

You coerce a `network` object into a `igraph` object as follows:

```{r}
intergraph::asIgraph(g)
```

You coerce a `igraph` object into a `network` object as follows:

```{r}
intergraph::asNetwork(g)
```

The `intergraph` package also has a useful function that turns a `network` or 
`igraph` object into a data.frame: 

```{r}
intergraph::asDF(g)
```

If you have a network in both `igraph` and `network` versions, 
you can check if they are (nearly) the same through the following `intergraph` 
function:

```{r}
# perform the test, result is TRUE or FALSE
intergraph::netcompare(network1, network2, test = TRUE)

# return the results of all the tests
intergraph::netcompare(network1, network2, test = FALSE)
```
<br><br><br>

# Transforming data into `igraph` and `network` classes

Very often the network data you want to manipulate with `igraph` and `network` does not come in the right format and you need to create the object. Below you can find the most popular functions that help you to do so. 

## `igraph`

* Load a graph with attributes 
```{r}
nodes <- utils::read.csv("file-NODES.csv", header = T, as.is = T)
links <- utils::read.csv("file-EDGES.csv", header = T, as.is = T)

net <- igraph::graph_from_data_frame(d=links, vertices=nodes, directed = T) 
```

* Make a graph from an adjacency matrix

```{r}
net <- igraph::graph_from_adjacency_matrix(adj_mat)
```

* Make a graph from an edge list

```{r}
net <- igraph::graph_from_edgelist(edgelist)
```

* Add node attributes
```{r}
net <- igraph::set_vertex_attr(net, 'attr_name', value = c(...))

```

* Add edge attribute

```{r}
net <- igraph::set_edge_attr(net, 'attr_name', value = c(...))
```


## `network`

* Make network from adjacency matrix
```{r}
net <- as.matrix.network(adj_mat)
```


* Make network from edge list

```{r}
net <- network::as.network(edgelist, matrix.type="edgelist")
```

* Add node attributes

```{r}
net <- network::set.vertex.attribute(net, 'attr_name', value = c(...))
```

* Add edge attribute
```{r}
net <- network::set.edge.attribute(net, 'attr_name', value = c(...))
```

# Computing measures

Below you will find a table with the main measures that are covered in the 
course. 
When both `igraph` and `network` provide a function for the measure, you will 
find both of them in the table.

<br>

```{r, echo = FALSE, eval = TRUE}
htmltools::includeHTML("html_measures.html")
```

<br><br><br>

# Communities and other subgroups

Networks often represent complex structures that are not uniformly connected. Very often we can observe sub-groups and communities.

## Manually subset graphs

You might want to separate a subgraph from the rest of the network with the function `induced_subgraph` you can do it calling the nodes by label or by number

```{r}
sub <- igraph::induced_subgraph(net, c('s01','s02'))

sub <- igraph::induced_subgraph(media_net, 1:7)
```

## Community detection

There are several algorithms implemented in `r` that allow the identification of communities inside networks.

### Walktrap algorithm
You can determine community structure via short random walks using the 
*walktrap* algorithm, as implemented in `igraph::walktrap.community`. 

You run this analysis as follows:

```{r}
igraph::cluster_walktrap(g)
```

You can adjust some of the settings, but the default setting almost 
always works well.
A general analysis approach works as follows:

```{r}
# run the algorithm
walk <- igraph::cluster_walktrap(g)

# get an overview of the results
print(walk)

# get the modularity score
igraph::modularity(walk)

# who is member of which community
igraph::communities(walk)

# which community is a vertex member of
igraph::membership(walk)

# number of communities
length(walk)

# size of each community
igraph::sizes(walk)

# which edge connects multiple communities
igraph::crossing(walk, g)

# plot the network, highlighting the communities
plot(walk, g)
```

I you are so inclined, 
you can plot the community division as a dendrogram, as follows:

```{r}
stats::as.hclust(walk) %>% plot()
```

### Girvan Newman Algorithm

The Girvan Newman Algorithm is based on the betweenness centrality. The edge betweenness score of an edge measures the number of shortest paths through it, see `edge_betweenness` for details. The idea of the edge betweenness based community structure detection is that it is likely that edges connecting separate modules have high edge betweenness as all the shortest paths from one module to another must traverse through them. So if we gradually remove the edge with the highest edge betweenness score we will get a hierarchical map, a rooted tree, called a dendrogram of the graph. The leafs of the tree are the individual vertices and the root of the tree represents the whole graph.

cluster_edge_betweenness performs this algorithm by calculating the edge betweenness of the graph, removing the edge with the highest edge betweenness score, then recalculating edge betweenness of the edges and again removing the one with the highest score, etc.

```{r}
ng <- igraph::cluster_edge_betweenness(net)

ng
```

Even if this algorithm handles directed networks, the modularity is computed with the undirected version only.


```{r}
igraph::modularity(ng)
```

The clusters can be plotted as a dendrogram
```{r}
igraph::plot_dendrogram(ng)
```



### Louvain Algorithm 

The function `cluster_louvain` implements the multi-level modularity optimization algorithm for finding community structure. It is based on the modularity measure and a hierarchial approach. 

It can be used only on undirected graphs. 

```{r}
cl <- cluster_louvain(igraph::as.undirected(net))

cl
```

extract the modularity from the assigned variable

```{r}
cl$modularity
```
Check to which group each node belongs to 

```{r}
data.frame(rbind(cl$names, cl$membership))

```

Plot the network with clusters
```{r}
plot(cl, net, vertex.label = NA, vertex.size=5, edge.arrow.size = .2)
```

<br><br><br>

# Plotting

<br> 

## Basic plotting in `igraph`

The `plot` function alone already plots nodes and edges with default options. More sophisticated specifications need to be manually set. It works with networks of class `igraph`.

```{r}
plot(net, 
     edge.arrow.size = .2,                # edge and arrow size
     edge.color = "red",                  # edge color
     vertex.color = "blue",               # vertex filling color
     vertex.frame.color = "green",        # vertex perimeter color
     vertex.label = igraph::V(net)$label, # vertex labels
     vertex.label.cex = 0.6,              # vertex label size
     vertex.label.color = "black")        # vertex label color
```


## Basic plotting in `network`

The `gplot` function alone already plots nodes and edges with default options. More sophisticated specifications need to be manually set. It works with networks of class `network`.


```{r}
gplot(net,
      arrowhead.cex = 0.2,     # edge and arrow size
      edge.col = 'red',        # edge color
      vertex.col = 'blue',     # vertex filling color
      vertex.border = 'green', # vertex perimeter color
      displaylabels = TRUE,    # vertex labels
      label.cex = 0.6,         # vertex label size
      label.col = 'black')     # vertex label color
```


## Basic plotting in `ggraph`

The `ggraph` function alone does not plot any data. Nodes, edges, and their attributes need to be specified layer after layer. It works both with networks of class `network` and `igraph`. It can be fully customized using the `ggplot2` toolkit. 

```{r}
ggraph::ggraph(net) +
  # put edges in the plot and make them red with an arrow
  ggraph::geom_edge_fan(color = "red", arrow = grid::arrow(length = grid::unit(4, 'mm'))) +
  # put vertexes in the plot and make them blue with size 5
  ggraph::geom_node_point(color = "blue", size = 5) +   
  # plot labels in black and size 5
  ggraph::geom_node_text(ggplot2::aes(label = media), size = 5, color = "black", repel = T) +
  # set background features
  ggplot2::theme_void() 
```

## SNA4DS functions
The `SNA4DS` package contains a function to plot centrality scores of the 
vertices. 
The function and its options are specified as follows:

```{r}
SNA4DS::centralityChart(
  net,
  measures = c("betweenness", "closeness", "degree"),
  directed = igraph::is.directed(net),
  mode = c("all", "out", "in", "total"),
  normalized = TRUE,
  path = FALSE
)
```

The function takes an object of class `igraph` and plots three centrality 
scores, so you can visually compare them. 
Make sure to pick the required value for `mode` (the default is "all"). 
You can leave `path` to `FALSE`, which will always work. 
If you want the dots to be connected (which can yield a more insightful plot), 
set `path = TRUE`, you then get a *path plot*. 
In some cases this yields a messy or messed-up plot, 
so then set `path = FALSE` again.

<br><br><br>

# Statistical models

Here is an overview of the statistical models discussed in the course.

<br>

```{r, echo = FALSE, eval = TRUE}
htmltools::includeHTML("html_models.html")
```

<br>

## Network autocorrelation models
The network autocorrelation model is run through the `sna::lnam` function.
The basic function call is as follows:

```{r}
sna::lnam(y, x = NULL, W1 = NULL, W2 = NULL)
```

Here, 

* `y` is a vector with a value for each vertex. 
The implementation in `sna::lnam` is only appropriate for continuous 
dependent variables.

* `W` is a matrix of the same dimension as the network, containing the weights 
that drive the network influence process. 
You need to specify `W1` and can include a second weight matrix `W2` if you want.

* `x` is a matrix with a row per vertex. Make sure to include a column with 1's, 
so an intercept is included. 
Make sure to include column names, so you get informative output.

There is a useful `summary` method (that shows you an overview of the results) 
and a `plot` method (that you use to check model assumptions).

<br>

## Conditional Uniform graphs (CUG)

There are two methods to perform a conditional Uniform graph test.

The first is to generate the graphs manually and calculate the 
measures on each graph.
Generation of these graphs can be done using `igraph::sample_gnm` (which 
conditions on size and density), `igraph::sample_gnp` (another way to 
condition on size and density). 
The equivalent functions in `sna` are `sna::rgraph` and `sna::rgnm`. 
See [the data generation table](#generate) for these functions.

The second approach is to use a function that does the graph generation and 
computes the network measure for you. 
The preferred is `sna::cugtest`, which is specified as follows:

```{r}
sna::cug.test(g, FUN, mode = c("digraph", "graph"), cmode = c("size", 
    "edges", "dyad.census"), reps = 1000, 
    ignore.eval = TRUE, FUN.args = list())
```

See the `sna` help function for details.

Here

* `FUN` is the function that needs to be calculated on each graph

* `FUN.args` contains any arguments that are required for the function you 
specified in `FUN`

* `cmode` determines the type of graphs that are drawn (ie. what you condition 
on). The options are 
  - "size": this generates graphs with a particular size and density 0.5. 
  You rarely want this.
  
  - "edges": this conditions on a specific edge count (or an 
  exact edge value distribution)
  
  - "dyad.census": this conditions on a dyad census (or dyad value distribution)


For example, in order to test whether the transitivity in your graph `g` is 
exceptional for a network of the same size and density as in `g`, you would run

```{r}
sna::cug.test(g, sna::gtrans, cmode = "edges")
```

It is wise to always explicitly tell the function whether your graph is 
directed or not, so a better way to specify the previous function is

```{r}
sna::cug.test(g, mode = "graph", FUN = sna::gtrans, 
              cmode = "edges", reps = 1000, 
              FUN.args = list(mode = "graph"))
```

Testing the betweenness centralization of you network `g` could be 
performed as follows, again conditioning on size and density:

```{r}
sna::cug.test(g,
              sna::centralization,
              FUN.arg=list(FUN = sna::betweenness), 
              mode="graph", 
              cmode="edges")
```

There is also a useful `plot` method for the result of the CUG test.

<br>

## QAP test

There are two methods to perform a QAP test.

The first is to manually permute the graph.
Generation of these graphs can be done using `igraph::permute` or `sna::rmperm`. 
See [the data generation table](#generate) for these functions.

The second approach is to use a function that does the graph permutation and 
computes the required measure (typically a correlation) for you. 
The preferred is `sna::qaptest`, which is specified as follows:

```{r}
sna::qaptest(g, FUN, reps = 1000, ...)
```

See the `sna` help function for details.

Here

* `FUN` is the function that needs to be calculated after each 
permutation

* `...` contains any arguments that are required for the function you 
specified in `FUN`

Typically, you want to test the correlation between two graphs, as follows:

```{r}
sna::qaptest(list(firstNetwork, secondNetwork), 
             FUN = sna::gcor, reps = 1000,
             g1 = 1, g2 = 2)
```

There is a useful `summary` method and a `plot` method for the output of the 
function.

<br>

## QAP linear regression

QAP linear regression is performed through the `sna::netlm` function.
The function looks as follows:


```{r}
sna::netlm(y, x, intercept = TRUE, mode = "digraph", 
    nullhyp = "qapspp", reps = 1000)
```

Make sure to always set `intercept = TRUE` and `nullhyp = "qapspp"`. 
For small networks, 1000 replications should be enough, 
for larger networks you should typically use a higher number (say, 2000).

As an example, this is how you specify a model where graph `g` is modeled 
as a linear function of graphs `g1`, `g2`, and `g3`.

```{r}
mod <- sna::netlm(y = g, x = list(g1, g2, g3), intercept = TRUE,
                              nullhyp = 'qapspp', reps = 1001)
mod$names <- c("Intcpt", "Net1", "Net2", "Net3")
summary(mod)
```

It is wise to add the names of the networks to the output object, like you 
see above. That is not strictly necessary, but it makes the output of the 
function easier to read.

<br>

## QAP logistic regression

QAP logistic regression is performed through the `sna::netlogit` function.
The function looks as follows:


```{r}
sna::netlogit(y, x, intercept = TRUE, mode = "digraph", 
    nullhyp = "qapspp", reps = 1000)
```

Make sure to always set `intercept = TRUE` and `nullhyp = "qapspp"`. 
For small networks, 1000 replications should be enough, 
for larger networks you should typically use a higher number (say, 2000).

As an example, this is how you specify a model where binary graph `g` is modeled 
as a function of graphs `g1`, `g2`, and `g3`.

```{r netlogit1, exercise = TRUE}
mod <- sna::netlogit(g, list(g1, g2, g3), 
                     intercept = TRUE,
                     nullhyp = "qapspp", reps = 1001)
mod$names <- c("Intcpt", "Net1", "Net2", "Net3")
summary(mod)
```

<br>

## Exponential Random Graph Model (ERGM)

An ERGM model is performed through the `ergm::ergm` function.
The basic function call is as follows:
```{r ergm }
fit <- ergm::ergm(formula)
```

The formula requires the specification of a network dependent variable, 
and a list of terms. 

Terms can be classified in three main ways.

* Dyadic independent and dyadic dependent terms: We encounter the first one when the probability of edge formation is related to nodes properties or attributes;  we encounter the second when the probability of edge formation depends on other existing edges. 

* Structural and nodal attributes terms: The first kind provides tools to understand the structure of the network per se; the second kind provides tools to explain how nodal attributes might have influenced the formation of edges. 

* Terms for directed networks and term for undirected networks



### Most popular structural - dyadic independent terms

* `edges` Extent to which the number of edges in the network characterizes the overall structure (Is it a random number of edges, or it is the meaningful outcome of a certain phenomenon?). Introduces one statistic to the model. Directed and Undirected networks.

* `density` Extent to which the network density characterizes the overall structure (Is it a random density, or it is the meaningful outcome of a certain phenomenon?). Introduces one statistic to the model. Directed and Undirected networks.

* `sender` Extent to which a specific node, compared to a baseline one, is sending out non-random edges (different from the same node's behavior in a random distribution). Introduces to the model as many statistics as the number of nodes minus one. Directed Networks only. 

* `receiver` Extent to which a specific node, compared to a baseline one, is receiving non-random edges (different from the same node's behavior in a random distribution). Introduces to the model as many statistics as the number of nodes minus one. Directed Networks only. 

### Most popular structural - dyadic dependent terms

* `mutual` Extent to which ties are more likely to be reciprocated than they would be in a random network (controlling for the other effects). Introduces one statistic to the model. Directed networks only. 

* `asymmetric` Extent to which the observed non reciprocated ties are non-random. Introduces one statistic to the model. Directed networks only.

* `triangles` Extent to which the observed triangles are non-random. Introduces one statistic to the model. Directed and Undirected networks. In the case of directed network measures “transitive triple” and “cyclic triple”, so triangle equals to `ttriple` plus `ctriple`. 

* `gwesp(decay=0.25, fixed=FALSE)` Geometrically weighted edgewise shared partner distribution. It can be used in place of triangles to improve convergence. The decay parameter should be non-negative. The value supplied for this parameter may be fixed (if `fixed=TRUE`), or it may be used instead as the starting value for the estimation of decay in a curved exponential family model (when `fixed=FALSE`, the default) (see Hunter and Handcock, 2006). This term can be used with directed and undirected networks. For directed networks, only outgoing two-path (`“OTP”`) shared partners are counted.  

* `dgwesp(decay=0.25, fixed=FALSE, type= 'RTP')` Geometrically weighted edgewise shared partner distribution. It also counts other types of shared partners not covered by `gwesp`: Outgoing Two-path (`“OTP”`), Incoming Two-path (`“ITP”`), Reciprocated Two-path (`“RTP”`), Outgoing Shared Partner (`“OSP”`), Incoming Shared Partner (`“ISP”`).

* `triadcensus` Extent to which the sixteen categories in the categorization of Davis and Leinhardt (1972) are observed in the network and are not generated at random. Introduces 16 statistics to the model. Directed networks only.

![Triad Census](C:\Users\20203861\Documents\SNA4DS\vignettes\triad_census.png)

* `balance` Extent to which type 102 or 300 in the categorization of Davis and Leinhardt (1972) -balanced triads- observed in the network are non-random. Introduces one statistic to the model. Directed networks only.

* `transitive` Extent to which type 120D, 030T, 120U, or 300 in the categorization of Davis and Leinhardt (1972) -transitive triads- observed in the network are non-random. Introduces one statistic to the model. Directed networks only.

* `intransitive` Extent to which type 111D, 201, 111U, 021C, or 030C in the categorization of Davis and Leinhardt (1972) -intransitive triads- observed in the network are non-random. Introduces one statistic to the model. Directed networks only.

* `degree(n)`, `idegree(n)`, `odegree(n)` Extent to which nodes with a specified degree are non random. Introduces one statistic to the model. Directed and Undirected networks, with the possibility of `in` and `out` specifications for Directed networks.

* `gwdegree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)`, `gwidegree(.5,fixed=T)`, `gwodegree(.5,fixed=T)` Geometrically weighted degree distribution. It can be used in place of `degree(n)` to improve convergence. Introduces one statistic to the model equal to the weighted degree distribution with decay controlled by the decay parameter. Directed and Undirected networks, with the possibility of `in` and `out` specifications for Directed networks.

* `kstar(n)`, `istar(n)`, `ostar(n)` Extent to which stars connecting the specified number of nodes are non random. Introduces one statistic to the model. Directed and Undirected networks, with the possibility of `in` and `out` specifications for Directed networks.

* `cycle(n)` Extent to which cycles with a specified number of nodes are non-random. Introduces one statistic to the model. Directed and Undirected networks.

### Most popular nodal covariate terms

* `nodecov`, `nodeicov`, `nodeocov` Numeric or Integer attributes. Extent to which the attribute values influence edge formation (same as in a logit model) so that it is non-random under that condition. Introduces one statistic to the model. Directed and Undirected networks, with the possibility of `in` and `out` specifications for Directed networks. Dyadic independent.

* `nodefactor`, `nodeifactor`, `nodeofactor` Categorical attributes. Extent to which nodes characterized by a specific category form more ties, so that tie formation is non-random under that condition. Introduces to the model a number of statistics equal to the number of categories minus one. Directed and Undirected networks, with the possibility of `in` and `out` specifications for Directed networks. Dyadic independent.

* `absdiff` Numeric or Integer attributes. Extent to which common features measured in terms of distance similarity influence edge formation, so that edge formation is non-random under that condition. Introduces one statistic to the model. Directed and Undirected networks. Dyadic independent.

* `nodematch` Categorical attributes. Extent to which nodes characterized by a specific category belonging to a certain attribute form ties with other node characterized by the same category, so that tie formation under that condition is non-random. Introduces to the model as many statistics as the number of categories. Directed and Undirected networks. Dyadic independent. ---Differential homophily

* `edgecov` Matrix attribute. Extent to which the ties formed in another context influence tie formation in the context of the current model, so that tie formation under that circumstances is non-random. Introduces one statistic to the model. Directed and Undirected networks. Dyadic dependent.

* `nodemix` Categorical attributes. Extent to which nodes denoted by different categories of an attribute form ties, so that tie formation under these circumstances is non-random. Introduces as many statistics as the number of combinations between every two categories. Directed and Undirected networks. Dyadic independent.
                          


### Terms specifications

Use the argument `levels` within the term specification for selecting the baseline or reference category. 

Example: set female as a reference category. 

```{r}
fit <- ergm::ergm(Net ~ edges + nodefactor('sex', levels = -(2)))
```


### Searching for terms

You can look for additional terms with 
```{r}
search.ergmTerms(keyword, net, categories, name)
```

You have four arguments to help you finding terms: 

* `keyword` optional character keyword to search for in the text of the term descriptions. Only matching terms will be returned. Matching is case insensitive.

* `net` a network object that the term would be applied to, used as template to determine directedness, bipartite, etc

* `categories` optional character vector of category tags to use to restrict the results (i.e. 'curved', 'triad-related') --see categorization of terms in the manual

* `name` optional character name of a specific term to return


### Checking your data before the analysis

Before you run any exponential random graph model you must know your data by heart.
Not only using descriptive network statistics, but also checking model specifications, 
before hitting the run button. 

* Manually check the attribute(s) (numeric, integer, categorical, ordinal)

```{r}
table(network::get.vertex.attribute(Net, 'sex'))
```


* check mixing of categorical attributes
```{r}
network::mixingmatrix(Net, "sex")
```

* check model statistics. 
```{r}
summary(Net ~ edges + nodefactor('sex'))
```

This last one provides the number of observed cases under the assumptions of each term.


### Reading results

You interpret ERGM results as logit models results. Two options: 

* Compute odd ratio for each coefficient

```{r}
OR <- exp(coef)
```

* Compute probability for each coefficient

```{r}
P <- exp(coef) / (1 + exp(coef))
```


### Simulating networks

It is sometimes helpful to simulate networks with the same features at the one you observed in real life. 

* Simulating a network from a model

```{r}
fit <- ergm::ergm(Net ~ edges)
simfit <- simulate(fit, burnin = 1e+6, verbose = TRUE, seed = 9)
```

* simulate network fixing the coefficient results

```{r}

RandomNet <- network::network(16,density=0.1,directed=FALSE)

sim <- simulate(~ edges + kstar(2), nsim = 2, coef = c(-1.8, 0.03),
                  basis = RandomNet, 
                  control = ergm::control.simulate(
                    MCMC.burnin=1000,
                    MCMC.interval=100))
sim[[1]]
```


### MCMC Diagostics

You can check the Monte Carlo Markov Chains diagnostic for your dyadic dependent model using the function:

```{r}
ergm::mcmc.diagnostics(fit)
```


### Goodness of Fit

You can check the goodness of fit of your model using the function 
```{r}
ergm::gof(fit)
```

You can also plot your `gof` output

```{r}
plot(ergm::gof(fit))
```

<br>

